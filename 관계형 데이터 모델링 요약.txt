*2. 전체흐름

	업무파악 -> 개념적 데이터 모델링 -> 논리적 데이터 모델링 -> 물리적 데이터 모델링
	
	업무파악: 의뢰자가 요구하는 기능이 무엇인지

	
	개념: 어떤 개념인지? 어떻게 상호작용 하는지?
	다이어그램 작성
	논리적: 관계형 데이터 베이스 패러다임에 맞게 수정
	물리적: 실제 코드 작성 (sql)

	=> 데이터 모델링이란? 문제를 현실로부터 뜯어내서 고도의 추상화 과정을 거져, 컴퓨터 세계로 옮겨내는 과정
		내 현실에 어울리는 고유의 모델링 기법을 찾아 나가야 한다.


*3. 업무파악 - 인트로

	우리가 구현하고자 하는 인터페이스가 어떤 UI를 갖을지 같이 그려보기.
	의뢰자와 생각을 일치시키는 것.

	복명복창 -> cross checking  => 생각의 동기화를 이뤄내야 한다.
	(COMMUNICATION)


*3.2 기획
ovenapp -> 기획서 작성을 통해 생각의 동기화

*4.1 개념적 데이터 모델링
	파악한 업무에서 개념을 뽑아낸다. 모델링의 가장 핵심적인 파트로, 4개 중 2번째 단계이지만 3, 4를 포함한 모든 단계를 이해하지 않고서는 수행할 수 없다.

	효용1. 현실에서 개념을 추출하는 "필터"를 제공
	효용2. 개념에 대해서 다른사람들과 교류할 수 있게 해주는 "언어"로서의 기능

	== Entity Relationship Diagram(ERD)
	현실을 3개의 관점으로 바라보는 finder :
	a. 정보: 정보 발견, 표현 // b. 서로 연관된 정보를 그룹핑, 표현 // c. 정보 그룹 사이의 관계를 인식하고, 표현		
	현실로부터 개념을 인식하고, 다른사람들에게 표현할 수 있게 해주는 도구!


*4.2 관계형 데이터베이스다운 개념의 구조

	우선, 서로 연관된 정보를 묶어주는 큰 덩어리들을 끌어낸다 (ex. 글, 저자, 댓글)

	글>댓글>저자 + 글>저자
	댓글 = 글 = 저자		->> 관계형 데이터 모델에 더 어울리는 모델
		==>>표를 분리해서primary key, foriegn key를 통해서 효율적으로 데이터 관리 가능
	
	장점 1. 주제에 따라 속성들을 그룹핑할 수 있다. 특정 정보만을 조회 함으로써 데이터 절약 가능하다.
	장점 2. "조인" 메커니즘** -> 필요할 때마다 필요한 정보들을 합성해낼 수 있다.
	**: SELECT 댓글.내용, 댓글.작성일, 저자.이름, 저자.소개 FROM 댓글 LEFT JOIN 저자 ON 댓글.저자 아이디 = 저자.아이디

	RDB는 내포관계를 허용하지 않는다. 평면 관계를 선호한다.


*4.3 ERD의 구성요소
	ENTITY(항목) -> TABLE로 전환
	ENTITY(EX.글) : 실제 DATA가 X  (구체적인 실제 데이터<ATTRIBUTE -> COLUMN으로 전환> EX. 제목, 생성일, 본문)

	ENTITY는 ATTRIBUTE를 포함할 수 있는 틀이다?

	--ENTITY간의 관계--
	저자 -<쓰다>- 글 -<소속>- 댓글
	저자 -<쓰다>- 댓글
	: Relation-> PF, FK으로 전환

	TUPLE(행) ->  ROW으로 전환


*4.4 ENTITY 정의

	UI <==> DB 서로 원인과 결과 관계

	STEP 01. 기획서에서 ENTITY를 찾아낸다. (연관된 데이터 그룹핑)
	TIP 읽기보다 쓰기 화면에서 ENTITY가 분병히 찾기 쉽다.


*4.5 ATTRIBUTE 정의

	모델링 작업과 UI 메이킹 작업은 끊임없이 커뮤니케이션을 하며 교차 검증을 해나가야 한다.


*4.6 IDENTIFIER(식별자) 지정
	고유값을 가져야 함. (중복값 X)
	인조 KEY 를 추가함으로써 식별자를 인위적으로 추가할 수 있음
	후보키(CANDIDATE KEY), 기본키(PRIMARY KEYY), 대체키(ALTERNATIVE KEY)
	중복키(COMPOSITE KEY) 두 가지 키를 동시에 대조함으로써 고유값 확인가능할 때.


*4.7 엔티티간의 연결(RELATIONSHIP)
	외래키(FOREIGHN KEY) 외래에 있는 다른 테이블과 연결하게 해줌.
	연결된 테이블들은 "RELATION"이 있다.


*4.8 CARDINALITY

	1:1 관계: 각 테이블의 한개의 ATTRIBUTE는 다른 테이블의 한 개의 ATTRIBUTE와만 관계를 맺을 수 있다.
	1:N 관계: 한 테이블의 한 ATTRIBUTE가 다른 테이블의 여러개의 ATTRIBUTE들과 관계를 맺을 수 았다. (저자:글, 저자:댓글)
	N:M 관계: 양측의 테이블이 서로 여러개의 ATTRIBUTE들과 관계를 맺을 수 있다.


*4.9 OPTIONALITY

	저자는 댓글을 작성하지 않을 수 도 있다. (OPTIONAL) | 로 표시
	각 댓글은 반드시 저자가 있어야 한다. (MADATORY)		O로 표시

		==> OPTIONALITY + CARDINALITY를 복합적으로 표현할 수 있고, 이를 해석할 수 있어야 한다.


*4.10 ERD 완성
	ERD 위에 관계를 표시하는 기호들을 채워넣어 준다.


*4.11 ERD HELPER
	(사이트 주소: erd.yah.ac)

*5.1 논리적 데이터 모델링

	-Mapping Rule
		다이어그램을 통해 표현한 내용을 관계형 DB로 전환하는 방법론
		Entity -> table
		Attribute -> column
		Relation -> PK, FK

*5.2 테이블과 컬럼 생성
	ER Master(ermaster.sourceforge.net)

entity 기반 table 생성 -> fk가 없는 table 먼저
	(domain, constraints 설정)

**Cardinality 처리
	*5.3 1:1 관계의 처리
		누가 누구에게 의존하고 있느냐가 중요.
		이 관계에 따라 누가 FK를 받아올지 알 수 있다. 주-종/ 부모-자식 관계 파악
 
	*5.4 1:N 관계의 처리
		1의 PK를 N이 FK로 받아옴
 
	*5.5 N:M 관계 처리
		중재자 -> mapping table 필요 

*6 정규화
	UNF(unnormalized form)을 RDB에 어울릴 수 있는 표로 가공하는 것.
	(bit.ly/2wV2SFj)
	
	*제 1 정규화
	중복되는 title, tag들을 정리한다.
	M : N 관계라면 mapping table을 통해 정리한다.
	최종적으로 모두 atomic한 column으로 가공하는 것이 목적.
	
	*제 2 졍규화
	종속성에 관한 것으로, FK에 완전종속된 column들과 부분종속된 column들을 분류한다.
	분류된 column들을 따로 분리하여 새로운 table을 만든다.
	
	*제 3 정규화
	No Transitive Dependencies(이행정 종속성)이 없어야 한다.
	ex) title > author_id > author_name, author_prof와 같은 종속 관계에서,
	author_name과 author_prof와는 author_id에 종속, title에 이행 종속이기 때문에 분리해주는 것이 좋다.

*7.1 물리적 데이터 모델링
	이상적인 표를 현실로 구현화 하는것. 'find slow query'문으로 병목을 해결하는 등
	퍼포먼스적 요소가 매우 중요하다. 사용 용도에 맞는 index, cache등의 활용을 통해 성능을 개선할 수 있다.
	
*7.2 Denormalization(역정규화)
	정규화 한 데이터(표)를 실용성이나 사용 용도에 맞게 다시 역정규화 하느 것.
	정규화를 거침에 따라 데이터가 여러 테이블로 분화되고 이렇게 찢어진 데이터를 불러오려면
	여러번의 join을 거쳐야 하는데, 이는 성능 하락의 원인이다.
	즉 : 정규화 - 쓰기 > 읽기, 역정규화 - 읽기 > 쓰기.
	단, 정규화를 먼저 하고 차후에 필요에 따라 역정규화 하는 것이 바람직하다.

*7.3 역정규화
	join의 개수를 줄인다 -> 읽기 속도 개선
				but, -> 중복 발생, 복잡도가 높아지고 고장 확률 증가
					=> 성능과 중복 사이에서 균형을 찾아야 한다.
	column조작, 표 쪼개기도 마찬가지이며 	=>> Trade-off를 따져야 한다.



	



















































